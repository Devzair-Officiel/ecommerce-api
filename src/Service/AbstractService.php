<?php

declare(strict_types=1);

namespace App\Service;

use App\Utils\JsonValidationUtils;
use App\Utils\DeserializationUtils;
use Doctrine\ORM\EntityManagerInterface;
use App\Exception\EntityNotFoundException;
use Symfony\Component\HttpKernel\Exception\BadRequestHttpException;

/**
 * Service abstrait offrant des fonctionnalitÃ©s gÃ©nÃ©riques pour la gestion des entitÃ©s.
 *
 * Cette classe fournit :
 * - La rÃ©cupÃ©ration sÃ©curisÃ©e d'une entitÃ© par son ID.
 * - La crÃ©ation et l'association dynamique d'entitÃ©s.
 * - La mise Ã  jour des relations entre entitÃ©s.
 * - La suppression d'une entitÃ©.
 *
 * Elle est destinÃ©e Ã  Ãªtre Ã©tendue par des services spÃ©cifiques aux entitÃ©s de l'application.
 */
abstract class AbstractService
{
    public function __construct(
        protected EntityManagerInterface $em,
        protected DeserializationUtils $deserializationUtils,
        protected JsonValidationUtils $jsonValidationUtils
    ) {}

    /**
     * RÃ©cupÃ¨re une entitÃ© par son ID ou lÃ¨ve une exception si elle n'existe pas.
     * 
     * @param string $entityClass
     * @param int $id
     * @throws \App\Exception\EntityNotFoundException
     */
    public function findEntityById(string $entityClass, int $id)
    {
        $entity = $this->em->getRepository($entityClass)->find($id);

        if (!$entity) {
            throw new EntityNotFoundException(strtolower(basename(str_replace('\\', '/', $entityClass))), ['id' => $id]);
        }

        return $entity;
    }

    /**
     * Marque une entitÃ© comme desactivÃ©e en lui assignant une date de clÃ´ture et valid Ã  false.
     *
     * @param object $entity L'entitÃ© Ã  fermer.
     */
    public function disableEntity(object $entity): void
    {
        $entityName = strtolower(basename(str_replace('\\', '/', $entity::class)));

        if (!$entity->isValid()) {
            throw new BadRequestHttpException(sprintf('%s.already_deactivated', $entityName));
        }

        $entity->setValid(false);
        $entity->setClosedAt(new \DateTimeImmutable());
        $this->em->flush();
    }

    /**
     * Marque une entitÃ© comme activÃ©e en lui assignant une date de clÃ´ture Ã  null et valid Ã  true.
     *
     * @param object $entity L'entitÃ© Ã  ouvrir.
     */
    public function enableEntity(object $entity): void
    {
        $entityName = strtolower(basename(str_replace('\\', '/', $entity::class)));

        if (!$entity->isValid()) {
            throw new BadRequestHttpException(sprintf('%s.already_deactivated', $entityName));
        }

        $entity->setValid(true);
        $entity->setClosedAt(null);
        $this->em->flush();
    }

    /**
     * Supprime dÃ©finitivement une entitÃ© de la base de donnÃ©es.
     *
     * @param object $entity L'entitÃ© Ã  supprimer.
     */
    public function deleteEntity(object $entity): void
    {
        $this->em->remove($entity);
        $this->em->flush();
    }


    /**
     * CrÃ©e et associe des entitÃ©s Ã  une relation donnÃ©e.
     *
     * - Si l'entitÃ© associÃ©e existe dÃ©jÃ , elle est rÃ©cupÃ©rÃ©e.
     * - Sinon, une nouvelle entitÃ© est crÃ©Ã©e si `$allowCreation` est `true`, sinon une erreur est levÃ©e.
     * - La relation est ajoutÃ©e dynamiquement Ã  l'entitÃ© principale.
     *
     * @param object  $mainEntity         L'entitÃ© principale.
     * @param string  $relationMethod     Nom de la relation (ex: "tags").
     * @param string  $relatedEntityClass Classe de l'entitÃ© associÃ©e.
     * @param string  $identifierKey      ClÃ© unique identifiant l'entitÃ© (ex: "id", "slug").
     * @param array   $jsonData           Tableau des nouvelles donnÃ©es Ã  associer.
     * @param bool    $allowCreation      Si `true`, crÃ©e une nouvelle entitÃ© si elle n'existe pas.
     *
     * @throws BadRequestHttpException    Si la clÃ© d'identification est absente des donnÃ©es.
     * @throws EntityNotFoundException    Si l'entitÃ© associÃ©e n'existe pas et `$allowCreation` est `false`.
     */
    public function createAndAssociateEntities(
        object $mainEntity,
        string $relationMethod,
        string $relatedEntityClass,
        string $identifierKey,
        array $jsonData,
        bool $allowCreation = true
    ): void {
        $repository = $this->em->getRepository($relatedEntityClass);

        $adder = 'add' . ucfirst($relationMethod);
        $setter = 'set' . ucfirst($relationMethod);

        foreach ($jsonData as $relatedData) {
            if (!isset($relatedData[$identifierKey])) {
                throw new BadRequestHttpException("Le champ '{$identifierKey}' est requis.");
            }

            $identifierValue = $relatedData[$identifierKey];
            $entity = $repository->findOneBy([$identifierKey => $identifierValue]);

            if (!$entity) {
                if (!$allowCreation) {
                    $className = strtolower((new \ReflectionClass($relatedEntityClass))->getShortName());
                    throw new EntityNotFoundException($className, [$identifierKey => $identifierValue]);
                }

                $entity = new $relatedEntityClass();
                $entitySetter = 'set' . ucfirst($identifierKey);

                if (method_exists($entity, $entitySetter)) {
                    $entity->$entitySetter($identifierValue);
                }

                $this->em->persist($entity);
            }

            // Association selon les mÃ©thodes disponibles sur l'entitÃ© principale
            if (method_exists($mainEntity, $adder)) {
                // ex: $user->addTag($tag)
                $mainEntity->$adder($entity);
            } elseif (method_exists($mainEntity, $setter)) {
                // ex: $user->setLaboratory($lab)
                $mainEntity->$setter($entity);
            } else {
                throw new \LogicException(sprintf(
                    "Aucune mÃ©thode d'association trouvÃ©e pour '%s' dans l'entitÃ© %s. Attendu : %s() ou %s().",
                    $relationMethod,
                    get_class($mainEntity),
                    $adder,
                    $setter
                ));
            }
        }
    }


    /**
     * Met Ã  jour une relation entre une entitÃ© principale et une collection d'entitÃ©s associÃ©es.
     * 
     * - Supprime les entitÃ©s associÃ©es qui ne sont plus dans la requÃªte.
     * - Ajoute ou met Ã  jour les entitÃ©s envoyÃ©es.
     * - GÃ¨re automatiquement les relations ManyToMany, OneToMany et ManyToOne.
     * 
     * @param object   $mainEntity         L'entitÃ© principale (ex: Denomination).
     * @param string   $relationMethod     Le nom de la relation (ex: "formePharmaceutiqueLovs").
     * @param string   $relatedEntityClass La classe de l'entitÃ© associÃ©e.
     * @param string   $identifierKey      La clÃ© unique pour identifier les entitÃ©s (ex: "title", "id").
     * @param array    $jsonData           Les nouvelles donnÃ©es Ã  appliquer.
     * @param bool     $allowCreation      Si `true`, crÃ©e l'entitÃ© si elle n'existe pas. Sinon, lÃ¨ve une erreur.
     */
    protected function updateAssociation(
        object $mainEntity,
        string $relationMethod,
        string $relatedEntityClass,
        string $identifierKey,
        array|int|string|null $jsonData,
        bool $allowCreation = true
    ): void {
        $repository = $this->em->getRepository($relatedEntityClass);

        $relationSingular = rtrim($relationMethod, 's');
        $getRelated    = "get" . ucfirst($relationMethod);       // ex: getTeams
        $addRelated    = "add" . ucfirst($relationSingular);     // ex: addTeam
        $removeRelated = "remove" . ucfirst($relationSingular);  // ex: removeTeam
        $setRelated    = "set" . ucfirst($relationMethod);       // ex: setLaboratory

        // ðŸ”¹ 1. Gestion spÃ©ciale du null explicite (cas ManyToOne Ã  annuler)
        if ($jsonData === null) {
            if (method_exists($mainEntity, $setRelated)) {
                $mainEntity->$setRelated(null);
            }
            return;
        }

        // ðŸ”¹ 2. Si on reÃ§oit une entitÃ© seule (ManyToOne) au format simple : ex. {"id": 1}
        if (!is_array($jsonData) || array_keys($jsonData) !== range(0, count($jsonData) - 1)) {
            if (!isset($jsonData[$identifierKey])) {
                throw new \InvalidArgumentException("Identifiant '$identifierKey' manquant pour la relation $relationMethod.");
            }

            $identifierValue = $jsonData[$identifierKey];
            $entity = $repository->findOneBy([$identifierKey => $identifierValue]);

            if (!$entity) {
                if (!$allowCreation) {
                    throw new EntityNotFoundException($relatedEntityClass, [$identifierKey => $identifierValue]);
                }

                $entity = new $relatedEntityClass();
                $setterMethod = 'set' . ucfirst($identifierKey);
                if (method_exists($entity, $setterMethod)) {
                    $entity->$setterMethod($identifierValue);
                }

                $this->em->persist($entity);
            }

            if (!method_exists($mainEntity, $setRelated)) {
                throw new \LogicException("La mÃ©thode '$setRelated' est manquante pour l'entitÃ© " . get_class($mainEntity));
            }

            $mainEntity->$setRelated($entity);
            return;
        }

        // ðŸ”¹ 3. On est ici dans un cas OneToMany ou ManyToMany (liste de relations)
        $identifiersInRequest = array_filter(array_map(fn($obj) => $obj[$identifierKey] ?? null, $jsonData));

        if (method_exists($mainEntity, $getRelated)) {
            $existingEntities = $mainEntity->$getRelated();

            foreach ($existingEntities as $existingEntity) {
                $existingIdentifier = $existingEntity->{"get" . ucfirst($identifierKey)}();
                if (!in_array($existingIdentifier, $identifiersInRequest, true)) {
                    if (method_exists($mainEntity, $removeRelated)) {
                        $mainEntity->$removeRelated($existingEntity);
                    } elseif (method_exists($existingEntity, $setRelated)) {
                        $existingEntity->$setRelated(null);
                    }
                }
            }
        }

        foreach ($jsonData as $relatedObject) {
            if (!isset($relatedObject[$identifierKey])) {
                continue;
            }

            $identifierValue = $relatedObject[$identifierKey];
            $entity = $repository->findOneBy([$identifierKey => $identifierValue]);

            if (!$entity) {
                if (!$allowCreation) {
                    throw new EntityNotFoundException($relatedEntityClass, [$identifierKey => $identifierValue]);
                }

                $entity = new $relatedEntityClass();
                $setterMethod = 'set' . ucfirst($identifierKey);

                if (method_exists($entity, $setterMethod)) {
                    $entity->$setterMethod($identifierValue);
                }

                $this->em->persist($entity);
            }

            // Ajout de la relation
            if (method_exists($mainEntity, $addRelated)) {
                if (!in_array($entity, $mainEntity->$getRelated()?->toArray() ?? [], true)) {
                    $mainEntity->$addRelated($entity);
                }
            } elseif (method_exists($mainEntity, $setRelated)) {
                $mainEntity->$setRelated($entity);
            } else {
                throw new \LogicException(sprintf(
                    "Aucune mÃ©thode d'association trouvÃ©e pour '%s' dans l'entitÃ© %s. Attendu : %s() ou %s().",
                    $relationMethod,
                    get_class($mainEntity),
                    $addRelated,
                    $setRelated
                ));
            }
        }
    }

    /**
     * VÃ©rifie que les clÃ©s fournies dans le tableau JSON correspondent bien aux propriÃ©tÃ©s de la classe cible.
     *
     * Cette mÃ©thode est utile pour valider en amont les donnÃ©es brutes d'une requÃªte JSON avant toute dÃ©sÃ©rialisation,
     * et Ã©viter ainsi l'instanciation d'une entitÃ© contenant des propriÃ©tÃ©s inattendues ou non mappÃ©es.
     *
     * @param array $jsonData     DonnÃ©es JSON sous forme de tableau associatif.
     * @param string $entityClass Nom complet de la classe de l'entitÃ© (ex: App\Entity\User\Division).
     *
     * @throws \InvalidArgumentException Si des clÃ©s invalides sont dÃ©tectÃ©es dans le JSON fourni.
     */
    protected function assertValidJsonKeys(array $jsonData, string $entityClass): void
    {
        $invalidKeys = $this->jsonValidationUtils->validateKeys($jsonData, $entityClass);

        if (!empty($invalidKeys)) {
            throw new \InvalidArgumentException(
                sprintf('ClÃ©s JSON invalides pour %s : %s', $entityClass, implode(', ', $invalidKeys))
            );
        }
    }
}
